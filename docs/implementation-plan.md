# What-to-Eat 实施计划

## 概述

本文档提供了 What-to-Eat 项目的详细实施计划。计划遵循以下原则：
- 每一步都小而具体，可独立完成
- 每一步都包含验证测试
- 聚焦于基础功能（MVP），完整功能后续添加
- 不包含代码，只提供清晰的指令

## 阶段划分

- **阶段 0：环境搭建** - 项目初始化、开发环境配置
- **阶段 1：后端基础** - 数据库、认证、基础 API（**必须先完成后端再开始前端**）
- **阶段 2：前端基础** - 项目初始化、基础页面、API 集成
- **阶段 3：核心功能 MVP** - 菜品推荐、饮食记录、健康分析
- **阶段 4：完整功能** - 图像识别、个性化推荐、高级分析（后续添加）

## 重要说明

### 开发顺序
- **严格遵循先后端后前端的顺序**：必须先完成所有后端 API 后再开始前端开发
- 后端每个 API 端点完成后，应使用 Postman 或 curl 进行完整测试

### 性能要求
- **接口响应时间**：所有 API 端点响应时间不能超过 1 秒
- **页面加载时间**：前端页面首次加载时间不能超过 1.5 秒
- 每个功能完成后需要进行性能测试

### 数据验证
- **前后端都需要数据验证**：前端进行基础验证（用户体验），后端进行完整验证（安全性）
- 前端验证失败时显示友好提示，后端验证失败时返回统一错误格式

---

## 阶段 0：环境搭建

### 0.1 初始化后端项目

**任务描述：**
- 在 `server` 目录下使用 NestJS CLI 创建新项目
- 配置 TypeScript、ESLint、Prettier
- 设置 pnpm 作为包管理工具

**验证测试：**
- 运行 `pnpm run start:dev`，服务器应成功启动在 3000 端口
- 访问 `http://localhost:3000`，应返回默认响应或 404
- 运行 `pnpm run build`，应成功编译无错误
- 运行 `pnpm run lint`，应无 lint 错误

### 0.2 配置后端环境变量

**任务描述：**
- 创建 `.env` 文件，包含数据库连接配置、JWT 密钥、端口等
- 安装并配置 `@nestjs/config` 模块
- 创建 `.env.example` 文件作为模板

**验证测试：**
- 启动应用，应能正确读取环境变量
- 修改 `.env` 中的端口，应用应在新端口启动
- 删除必需的环境变量，应用应显示明确的错误信息

### 0.3 初始化前端项目

**任务描述：**
- 在 `mobile` 目录下使用 Expo CLI 创建新项目
- 选择 TypeScript 模板
- 配置 ESLint、Prettier
- 设置 pnpm 作为包管理工具

**验证测试：**
- 运行 `pnpm expo start`，开发服务器应成功启动
- 在 Expo Go 应用中扫描二维码，应能看到默认的欢迎界面
- 运行 `pnpm run lint`，应无 lint 错误

### 0.4 配置前端环境变量

**任务描述：**
- 创建 `.env` 文件，包含 API 基础 URL
- 配置 Expo 环境变量（使用 `EXPO_PUBLIC_` 前缀）
- 创建 `.env.example` 文件

**验证测试：**
- 在代码中访问环境变量，应能正确读取
- 修改 API URL，应用应使用新的 URL

### 0.5 设置数据库

**任务描述：**
- 安装并启动 PostgreSQL 数据库
- 创建项目数据库 `what_to_eat`
- 创建数据库用户并授予权限

**验证测试：**
- 使用 `psql` 连接到数据库，应成功连接
- 运行 `\l` 命令，应能看到 `what_to_eat` 数据库
- 使用创建的用户登录，应能访问数据库

---

## 阶段 1：后端基础

### 1.1 配置 TypeORM 和数据库连接

**任务描述：**
- 安装 TypeORM 和 PostgreSQL 驱动
- 在 `app.module.ts` 中配置 TypeORM 模块
- 使用环境变量配置数据库连接参数

**验证测试：**
- 启动应用，应成功连接到数据库
- 检查日志，应无数据库连接错误
- 断开数据库，应用应显示明确的连接错误信息

### 1.2 创建用户实体（User Entity）

**任务描述：**
- 创建 `User` 实体类，包含字段：id, username, email, passwordHash, createdAt, updatedAt
- 添加用户资料字段（用于健康分析）：height (身高，cm), weight (体重，kg), age (年龄), gender (性别：male/female)
- 使用 TypeORM 装饰器定义实体和字段
- 设置 username 和 email 为唯一字段
- 资料字段使用 JSONB 类型存储，或创建单独的 profile 字段

**验证测试：**
- 运行 `pnpm run migration:generate`，应生成迁移文件
- 运行 `pnpm run migration:run`，应在数据库中创建 users 表
- 使用数据库客户端查看表结构，应包含所有定义的字段
- 尝试插入重复的 username 或 email，应抛出唯一约束错误
- 插入包含用户资料的数据，应成功保存

### 1.3 创建用户模块基础结构

**任务描述：**
- 创建 `users` 模块目录结构
- 创建 `users.module.ts`，注册 TypeORM 特性模块
- 创建 `users.service.ts` 和 `users.controller.ts`（暂时为空实现）

**验证测试：**
- 启动应用，应无模块导入错误
- 访问 `/users` 路由，应返回 404 或空响应（路由未实现时）

### 1.4 实现用户注册 DTO 和验证

**任务描述：**
- 创建 `CreateUserDto`，包含 username, email, password 字段
- 创建 `UpdateUserProfileDto`，包含 height, weight, age, gender 字段（可选）
- 使用 class-validator 添加验证规则：
  - username: 3-50 字符，必填
  - email: 格式验证，必填
  - password: 最少 6 字符，必填
  - height: 数字，范围 50-250（cm），可选
  - weight: 数字，范围 20-300（kg），可选
  - age: 数字，范围 1-150，可选
  - gender: 枚举值（male/female），可选
- 在控制器中配置全局验证管道

**验证测试：**
- 发送无效的注册请求（如空字段、格式错误），应返回 400 错误和验证错误信息
- 发送有效的注册请求，应通过验证（即使业务逻辑未实现）
- 发送包含用户资料的注册请求，应通过验证

### 1.5 实现密码加密功能

**任务描述：**
- 安装 bcrypt
- 在用户服务中创建密码加密工具函数
- 实现密码哈希和验证方法

**验证测试：**
- 对同一密码进行两次哈希，结果应不同（因为 salt）
- 使用哈希后的密码调用验证函数，应返回 true
- 使用错误密码调用验证函数，应返回 false

### 1.6 实现用户注册服务逻辑

**任务描述：**
- 在 `users.service.ts` 中实现 `create` 方法
- 检查用户名和邮箱是否已存在
- 加密密码并保存用户到数据库

**验证测试：**
- 注册新用户，应成功创建并返回用户信息（不含密码）
- 尝试注册已存在的用户名，应抛出冲突异常
- 尝试注册已存在的邮箱，应抛出冲突异常
- 检查数据库，密码应为哈希值，不是明文

### 1.7 配置 API 版本控制

**任务描述：**
- 安装并配置 NestJS 版本控制模块
- 设置全局 API 前缀为 `/v1`
- 所有 API 端点应使用 `/v1` 前缀

**验证测试：**
- 访问 `/v1/users` 应能正确路由
- 访问 `/users`（无版本）应返回 404 或版本错误
- 所有后续创建的端点都应包含 `/v1` 前缀

### 1.8 配置 Swagger 文档

**任务描述：**
- 安装 `@nestjs/swagger` 模块
- 在 `main.ts` 中配置 Swagger
- 设置 API 文档路径为 `/api-docs`
- 为所有 DTO 和控制器添加 Swagger 装饰器

**验证测试：**
- 启动应用，访问 `/api-docs`，应显示 Swagger UI
- 所有已实现的端点应在文档中显示
- 点击端点应能看到请求/响应示例
- 可以在 Swagger UI 中测试 API

### 1.9 实现全局错误处理和错误码

**任务描述：**
- 创建全局异常过滤器
- 定义统一错误码规范（如：AUTH_001, USER_001, DISH_001 等）
- 统一错误响应格式：`{ success: false, error: { code: string, message: string } }`
- 处理常见异常：NotFoundException, BadRequestException, UnauthorizedException 等

**验证测试：**
- 触发各种错误，应返回统一格式的错误响应
- 错误码应清晰明确
- 错误信息应对用户友好（不暴露技术细节）
- 检查日志，应记录详细错误信息（开发环境）

### 1.10 实现用户注册 API 端点

**任务描述：**
- 在 `users.controller.ts` 中创建 `POST /v1/users/register` 端点
- 调用服务层创建用户
- 返回统一的成功响应格式：`{ success: true, data: {...}, message: string }`
- 使用 Swagger 装饰器添加文档

**验证测试：**
- 使用 Postman 或 curl 发送注册请求，应返回 201 状态码和用户信息
- 响应中不应包含 passwordHash 字段
- 重复注册相同用户，应返回 409 冲突错误和统一错误格式
- 在 Swagger UI 中测试，应能成功注册

### 1.11 配置 JWT 认证模块

**任务描述：**
- 安装 `@nestjs/jwt` 和 `@nestjs/passport`、`passport`、`passport-jwt`
- 创建 JWT 模块，配置密钥和过期时间
- 创建 JWT 策略（Passport Strategy）

**验证测试：**
- 使用测试密钥生成 JWT token，应能成功生成
- 解析生成的 token，应能正确提取 payload
- 使用过期 token，应抛出过期错误

### 1.12 实现用户登录服务

**任务描述：**
- 在 `users.service.ts` 中实现 `validateUser` 方法
- 根据用户名或邮箱查找用户
- 验证密码是否正确

**验证测试：**
- 使用正确的用户名和密码，应返回用户对象
- 使用错误的密码，应返回 null
- 使用不存在的用户名，应返回 null

### 1.13 实现用户登录 API 端点

**任务描述：**
- 创建 `auth` 模块
- 在 `auth.controller.ts` 中创建 `POST /v1/auth/login` 端点
- 验证用户凭据，生成并返回 JWT token
- 返回统一响应格式
- 使用 Swagger 装饰器添加文档

**验证测试：**
- 使用正确凭据登录，应返回 200 状态码和包含 token 的响应
- 使用错误密码登录，应返回 401 未授权错误和统一错误格式
- 使用不存在的用户登录，应返回 401 未授权错误和统一错误格式
- 使用返回的 token 访问受保护路由，应能成功访问（如果已实现保护）
- 在 Swagger UI 中测试，应能成功登录

### 1.14 创建 JWT 认证守卫

**任务描述：**
- 创建 `JwtAuthGuard`，继承 Passport 的 AuthGuard
- 配置守卫从请求头中提取 token
- 验证 token 并提取用户信息到 request.user

**验证测试：**
- 使用有效 token 访问受保护路由，应能成功访问
- 使用无效 token 访问，应返回 401 错误
- 不使用 token 访问，应返回 401 错误
- 在控制器中访问 `@CurrentUser()` 装饰器，应能获取用户信息

### 1.15 创建当前用户装饰器

**任务描述：**
- 创建 `@CurrentUser()` 自定义参数装饰器
- 从 request.user 中提取当前登录用户

**验证测试：**
- 在受保护的控制器方法中使用装饰器，应能正确获取用户对象
- 在未认证的请求中使用，应返回 undefined 或抛出错误

### 1.16 实现获取用户信息 API

**任务描述：**
- 在 `users.controller.ts` 中创建 `GET /v1/users/profile` 端点
- 使用 JWT 守卫保护路由
- 返回当前登录用户的信息（包含用户资料）
- 使用 Swagger 装饰器添加文档

**验证测试：**
- 使用有效 token 访问，应返回用户信息
- 不使用 token 访问，应返回 401 错误和统一错误格式
- 响应中不应包含敏感信息（如 passwordHash）
- 在 Swagger UI 中测试（需要先登录获取 token）

### 1.17 实现更新用户资料 API

**任务描述：**
- 创建 `UpdateUserProfileDto`，包含 height, weight, age, gender 字段
- 在 `users.controller.ts` 中创建 `PUT /v1/users/profile` 端点
- 使用 JWT 守卫保护路由
- 更新用户的资料信息
- 使用 Swagger 装饰器添加文档

**验证测试：**
- 使用有效 token 更新资料，应成功更新
- 更新后查询用户信息，应显示新资料
- 验证规则应正常工作（如年龄范围）
- 不使用 token 访问，应返回 401 错误

---

## 阶段 2：前端基础

### 2.1 安装和配置基础依赖

**任务描述：**
- 安装 React Query、Zustand、axios、React Hook Form
- 安装 React Native Paper UI 库
- 配置 Expo Router

**验证测试：**
- 运行 `pnpm install`，所有依赖应成功安装
- 导入主要库，应无导入错误
- 运行应用，应无运行时错误

### 2.2 创建 API 服务基础结构

**任务描述：**
- 创建 `services/api.ts`，配置 axios 实例
- 设置基础 URL 从环境变量读取（包含 `/v1` 前缀）
- 配置请求和响应拦截器
- **实现响应拦截器错误处理**：统一处理 API 错误，转换为友好的错误信息
- 创建错误消息映射：将后端错误码转换为用户友好的中文提示

**验证测试：**
- 发送测试请求，应能正确使用配置的 baseURL
- 检查控制台，应能看到请求日志
- 修改环境变量中的 API URL，请求应使用新 URL
- 收到 API 错误时，应显示友好的错误信息（不是技术错误）

### 2.3 实现 API 请求拦截器（添加 Token）

**任务描述：**
- 在请求拦截器中从 Zustand store 获取 token
- 如果存在 token，添加到请求头的 Authorization 字段
- 格式：`Bearer {token}`

**验证测试：**
- 在 store 中设置 token，发送请求，应能在请求头中看到 Authorization
- 清除 token，发送请求，应不包含 Authorization 头
- 使用 Postman 验证后端收到的请求头是否正确

### 2.4 创建认证 Store（Zustand）

**任务描述：**
- 创建 `store/authStore.ts`
- 定义状态：user, token, isAuthenticated
- 实现 actions：login, logout, setUser

**验证测试：**
- 在组件中使用 store，应能读取初始状态
- 调用 login action，状态应更新
- 调用 logout action，状态应清空
- 使用 React DevTools 检查状态变化

### 2.5 实现登录 API 调用

**任务描述：**
- 在 `services/auth.ts` 中创建 `login` 函数
- 调用后端 `/auth/login` 端点
- 返回 token 和用户信息

**验证测试：**
- 使用正确凭据调用，应返回 token
- 使用错误凭据调用，应抛出错误
- 检查网络请求，应发送到正确的端点

### 2.6 实现登录页面 UI（含前端验证和友好错误）

**任务描述：**
- 创建登录页面组件
- 使用 React Hook Form 创建表单
- 添加用户名/邮箱和密码输入框
- 添加登录按钮
- **实现前端验证**：必填字段验证、邮箱格式验证
- **显示友好错误信息**：验证错误和 API 错误都显示用户友好的提示
- 添加加载状态：登录时按钮显示加载动画

**验证测试：**
- 页面应正确渲染表单
- 输入验证应正常工作（如必填字段）
- 验证错误应显示友好的中文提示
- 提交表单，应触发表单提交事件
- 登录时按钮应显示加载状态
- API 错误应显示友好提示（不是技术错误）

### 2.7 实现登录功能集成

**任务描述：**
- 在登录页面中调用登录 API
- 成功后更新 authStore
- 导航到主页或重定向

**验证测试：**
- 使用正确凭据登录，应成功并更新 store
- 登录后应导航到主页
- 使用错误凭据，应显示错误信息
- 检查 store，token 和 user 应已设置

### 2.8 实现注册页面 UI（含前端验证和友好错误）

**任务描述：**
- 创建注册页面组件
- 添加用户名、邮箱、密码、确认密码输入框
- 添加注册按钮
- **实现前端验证**：所有字段必填验证、邮箱格式验证、密码长度验证、密码匹配验证
- **显示友好错误信息**：验证错误和 API 错误都显示用户友好的提示
- 添加加载状态：注册时按钮显示加载动画

**验证测试：**
- 页面应正确渲染所有输入框
- 密码和确认密码应匹配验证
- 表单验证应正常工作
- 验证错误应显示友好的中文提示
- API 错误应显示友好提示（如"用户名已存在"而不是技术错误）
- 注册时按钮应显示加载状态

### 2.9 实现注册功能集成

**任务描述：**
- 在注册页面中调用注册 API
- 成功后自动登录或跳转到登录页

**验证测试：**
- 注册新用户，应成功创建账户
- 尝试注册已存在的用户，应显示错误信息
- 注册成功后应导航到登录页或自动登录

### 2.10 创建受保护路由守卫

**任务描述：**
- 创建路由守卫组件或 Hook
- 检查用户是否已认证
- 未认证时重定向到登录页

**验证测试：**
- 未登录时访问受保护页面，应重定向到登录页
- 登录后访问受保护页面，应正常显示
- 登出后访问受保护页面，应重定向到登录页

### 2.11 实现用户信息获取和显示（含骨架屏）

**任务描述：**
- 使用 React Query 创建获取用户信息的 query
- 在个人中心页面显示用户信息
- **实现骨架屏**：数据加载时显示骨架屏
- **处理错误状态**：显示友好的错误信息
- 显示用户资料（身高、体重、年龄、性别）

**验证测试：**
- 登录后访问个人中心，应显示用户信息
- 未登录时访问，应重定向或显示错误
- 加载时应显示骨架屏（不是空白）
- 网络错误时，应显示友好的错误信息（不是技术错误）
- 用户资料应正确显示

---

## 阶段 3：核心功能 MVP

### 3.1 创建菜品实体（Dish Entity）

**任务描述：**
- 创建 `Dish` 实体，包含字段：id, name, category, cuisineType, nutrition (JSONB), tags (数组), description, createdAt
- nutrition 字段存储营养成分对象（calories, protein, fat, carbs）
- **注意：MVP 阶段不包含 imageUrl 字段（先支持文本）**
- 添加 userId 字段（可选），用于标识创建者（支持用户手动录入）
- 创建数据库迁移

**验证测试：**
- 运行迁移，应在数据库中创建 dishes 表
- 插入测试数据，应成功保存
- 查询数据，nutrition 字段应正确解析为对象
- tags 数组字段应正确存储和查询
- 插入包含 userId 的数据，应成功保存

### 3.2 创建菜品模块基础结构

**任务描述：**
- 创建 `dishes` 模块
- 创建 module, controller, service 文件
- 注册 TypeORM 特性模块

**验证测试：**
- 启动应用，应无模块错误
- 模块应正确导入到 app.module

### 3.3 实现获取菜品列表 API

**任务描述：**
- 在 `dishes.service.ts` 中实现 `findAll` 方法
- 支持分页（page, limit）
- 支持按 category 和 cuisineType 筛选
- 在 `dishes.controller.ts` 中创建 `GET /v1/dishes` 端点
- 使用 Swagger 装饰器添加文档

**验证测试：**
- 访问端点，应返回菜品列表
- 使用分页参数，应返回正确数量的结果
- 检查响应格式，应包含分页信息
- 使用筛选参数，应返回匹配的菜品
- 响应时间应小于 1 秒

### 3.4 实现获取单个菜品详情 API

**任务描述：**
- 在 service 中实现 `findOne` 方法
- 在 controller 中创建 `GET /v1/dishes/:id` 端点
- 处理菜品不存在的情况，返回统一错误格式
- 使用 Swagger 装饰器添加文档

**验证测试：**
- 使用有效 ID 访问，应返回菜品详情
- 使用无效 ID 访问，应返回 404 错误和统一错误格式
- 响应应包含完整的菜品信息
- 响应时间应小于 1 秒

### 3.5 实现创建菜品 API（用户手动录入）

**任务描述：**
- 创建 `CreateDishDto`，包含 name, category, cuisineType, nutrition, tags, description 字段
- 添加验证规则：name 必填，nutrition 对象必填且包含 calories, protein, fat, carbs
- 在 service 中实现 `create` 方法
- 在 controller 中创建 `POST /v1/dishes` 端点
- 使用 JWT 守卫保护路由（只有登录用户才能创建）
- 保存创建者 userId
- 使用 Swagger 装饰器添加文档

**验证测试：**
- 使用有效 token 创建菜品，应成功创建并返回 201
- 未认证时创建，应返回 401 错误
- 发送无效数据，应返回验证错误
- 检查数据库，应包含 userId
- 响应时间应小于 1 秒

### 3.6 实现营养成分计算工具函数

**任务描述：**
- 创建营养成分计算工具模块
- 实现根据菜品名称和分量估算营养成分的函数
- **注意：无现成数据库，使用简单规则或固定值**
- 可以基于菜品名称关键词匹配（如"鸡"对应高蛋白，"蔬菜"对应低卡路里）
- 或提供默认营养成分值供用户修改

**验证测试：**
- 输入不同菜品名称，应返回合理的营养成分估算
- 营养成分值应在合理范围内
- 函数应能处理未知菜品（返回默认值）

### 3.7 创建菜品种子数据脚本

**任务描述：**
- 创建数据库种子脚本（seed script）
- 准备初始菜品数据（至少 20-30 个常见菜品）
- 包含完整的营养成分数据
- 脚本应可重复运行（幂等性）
- 在 `package.json` 中添加 seed 命令

**验证测试：**
- 运行种子脚本，应成功插入数据
- 多次运行脚本，不应产生重复数据
- 检查数据库，应包含所有初始菜品
- 每个菜品应包含完整的营养成分

### 3.8 实现随机推荐菜品 API

**任务描述：**
- 在 service 中实现 `getRandom` 方法
- 从数据库中随机选择一条菜品记录
- 在 controller 中创建 `GET /v1/dishes/recommend/random` 端点
- 使用 Swagger 装饰器添加文档

**验证测试：**
- 多次调用端点，应返回不同的菜品（或可能相同，因为是随机）
- 数据库中无菜品时，应返回 404 或统一错误格式
- 响应应包含完整的菜品信息
- 响应时间应小于 1 秒

### 3.9 创建前端菜品类型定义

**任务描述：**
- 在 `types/` 目录创建 `dish.ts`
- 定义 Dish 接口，匹配后端实体结构

**验证测试：**
- 在组件中使用类型，应无类型错误
- TypeScript 编译应通过

### 3.10 实现获取菜品列表的 React Query Hook

**任务描述：**
- 在 `services/dishes.ts` 中创建 API 调用函数
- 创建自定义 Hook `useDishes`，使用 React Query
- 支持分页参数

**验证测试：**
- 在组件中使用 Hook，应能获取数据
- 检查网络请求，应发送到正确端点
- 数据应正确缓存

### 3.11 实现推荐页面 UI（含骨架屏和加载动画）

**任务描述：**
- 创建推荐页面组件
- 显示随机推荐的菜品
- 添加"换一个"按钮，重新获取推荐
- **实现骨架屏**：数据加载时显示骨架屏占位符
- **实现加载动画**：按钮点击时显示加载动画
- 使用 React Native Paper 的 ActivityIndicator 或自定义加载组件

**验证测试：**
- 页面应显示菜品信息（名称、描述等）
- 点击"换一个"按钮，应获取新的推荐
- 加载状态应显示骨架屏（不是空白）
- 按钮点击时应显示加载动画
- 错误状态应显示友好的错误信息
- 页面首次加载时间应小于 1.5 秒

### 3.12 创建饮食记录实体（DietRecord Entity）

**任务描述：**
- 创建 `DietRecord` 实体
- 包含字段：id, userId, date, mealType, dishes (JSONB), totalCalories, nutritionInfo (JSONB), createdAt
- 建立与 User 的外键关系
- 创建数据库迁移

**验证测试：**
- 运行迁移，应创建 diet_records 表
- 插入测试记录，应成功保存
- 查询时关联用户，应正确返回
- 删除用户时，应级联删除记录（如果配置了）

### 3.13 创建饮食记录模块

**任务描述：**
- 创建 `diet-records` 模块
- 创建 module, controller, service 文件
- 注册模块和实体

**验证测试：**
- 启动应用，应无模块错误
- 模块应正确导入

### 3.14 实现创建饮食记录 DTO

**任务描述：**
- 创建 `CreateDietRecordDto`
- 包含字段：date, mealType, dishes (数组)
- 添加验证规则：date 必填，mealType 枚举值，dishes 非空数组

**验证测试：**
- 发送无效数据，应返回验证错误
- 发送有效数据，应通过验证

### 3.15 实现创建饮食记录服务逻辑

**任务描述：**
- 在 service 中实现 `create` 方法
- 根据 dishes 数组计算总卡路里和营养信息
- 保存记录到数据库

**验证测试：**
- 创建记录，应成功保存
- 检查数据库，totalCalories 和 nutritionInfo 应正确计算
- 使用不同 mealType，应正确保存

### 3.16 实现创建饮食记录 API

**任务描述：**
- 在 controller 中创建 `POST /v1/diet-records` 端点
- 使用 JWT 守卫保护
- 从 token 中获取用户 ID
- 调用 service 创建记录
- 返回统一响应格式
- 使用 Swagger 装饰器添加文档

**验证测试：**
- 使用有效 token 创建记录，应返回 201 和记录信息
- 未认证时创建，应返回 401 和统一错误格式
- 检查数据库，记录应正确关联到用户
- 响应时间应小于 1 秒

### 3.17 实现获取用户饮食记录列表 API

**任务描述：**
- 在 service 中实现 `findByUser` 方法
- 支持按日期范围筛选
- 支持按 mealType 筛选
- 在 controller 中创建 `GET /v1/diet-records` 端点
- 使用 JWT 守卫保护
- 使用 Swagger 装饰器添加文档

**验证测试：**
- 获取当前用户的记录，应只返回该用户的记录
- 使用日期范围筛选，应返回正确范围的记录
- 使用 mealType 筛选，应返回匹配的记录
- 未认证时访问，应返回 401 和统一错误格式
- 响应时间应小于 1 秒

### 3.18 创建前端饮食记录类型定义

**任务描述：**
- 创建 `DietRecord` 接口
- 创建 `CreateDietRecordDto` 接口
- 定义 mealType 枚举

**验证测试：**
- TypeScript 编译应通过
- 类型应与后端匹配

### 3.19 实现创建饮食记录的 React Query Mutation

**任务描述：**
- 在 `services/diet-records.ts` 中创建 API 调用函数
- 创建 `useCreateDietRecord` Hook
- 配置成功后的缓存更新

**验证测试：**
- 调用 mutation，应发送正确请求
- 成功后，相关查询应自动更新
- 错误应正确处理

### 3.20 实现饮食记录页面 UI（含骨架屏）

**任务描述：**
- 创建饮食记录页面
- 显示今日三餐（早餐、午餐、晚餐、加餐）
- 每个餐次显示添加按钮或已有记录

**验证测试：**
- 页面应正确显示四个餐次区域
- 未记录时显示添加按钮
- 已记录时显示记录信息

### 3.21 实现添加饮食记录表单（含前端验证）

**任务描述：**
- 创建添加记录的表单组件
- 包含日期选择、餐次选择、菜品选择（手动输入菜品名称）
- 使用 React Hook Form 管理表单
- **实现前端验证**：必填字段验证、日期格式验证、餐次枚举验证
- 显示友好的验证错误信息
- 提交时显示加载状态

**验证测试：**
- 表单应正确渲染
- 前端验证应正常工作（提交空表单应显示错误）
- 验证错误信息应友好易懂
- 提交表单，应调用创建 API
- 提交时按钮应显示加载状态

### 3.22 实现饮食记录列表显示（含骨架屏）

**任务描述：**
- 使用 React Query 获取用户的饮食记录
- 按日期和餐次分组显示
- 显示菜品名称和卡路里
- **实现骨架屏**：数据加载时显示列表骨架屏
- **实现空状态**：无记录时显示友好的空状态提示

**验证测试：**
- 应正确显示所有记录
- 记录应按日期排序
- 加载时应显示骨架屏（不是空白）
- 空状态应显示友好的提示信息
- 页面加载时间应小于 1.5 秒

### 3.23 实现基于中国居民膳食指南的推荐摄入量计算

**任务描述：**
- 创建推荐摄入量计算工具模块
- 根据用户年龄、性别、活动量计算推荐摄入量
- 参考《中国居民膳食指南》标准
- 计算基础代谢率（BMR）和总能量消耗（TDEE）
- 计算三大营养素推荐量（蛋白质、脂肪、碳水化合物）
- 考虑不同年龄段和性别的差异

**验证测试：**
- 输入不同用户信息，应返回合理的推荐摄入量
- 男性推荐量应高于女性（相同条件下）
- 活动量大的人推荐量应高于活动量小的人
- 计算结果应在合理范围内

### 3.24 实现基础健康分析服务

**任务描述：**
- 创建 `health-analysis` 模块
- 在 service 中实现 `analyzeDaily` 方法
- 计算当日总卡路里、蛋白质、脂肪、碳水化合物
- 调用推荐摄入量计算工具，获取用户个性化推荐量
- 对比实际摄入与推荐摄入量
- 计算各项营养的完成百分比

**验证测试：**
- 分析有记录的日期，应返回营养统计和对比结果
- 分析无记录的日期，应返回空或默认值
- 计算结果应准确（手动验证）
- 对比结果应正确反映摄入情况

### 3.21 实现健康评分算法（基础版）

**任务描述：**
- 在健康分析服务中实现 `calculateHealthScore` 方法
- 基于卡路里合理性评分（30%）
- 基于营养均衡度评分（40%）
- 基于食物多样性评分（20%）
- 基于健康食材比例评分（10%）
- 返回 0-100 的分数

**验证测试：**
- 输入不同的饮食数据，应返回合理的分数
- 极端情况（如只吃一种食物），分数应较低
- 均衡饮食，分数应较高
- 分数应在 0-100 范围内

### 3.25 实现获取健康分析 API

**任务描述：**
- 在 controller 中创建 `GET /v1/health-analysis/today` 端点
- 使用 JWT 守卫保护路由
- 获取今日饮食记录
- 获取用户资料（年龄、性别、身高、体重）
- 调用分析服务计算健康评分和营养分析
- 返回分析结果（包含推荐摄入量、实际摄入量、完成百分比）
- 使用 Swagger 装饰器添加文档

**验证测试：**
- 有记录时，应返回完整的分析结果
- 无记录时，应返回默认值或提示
- 未认证时，应返回 401 和统一错误格式
- 用户未设置资料时，应使用默认值或提示用户完善资料
- 响应时间应小于 1 秒

### 3.26 实现健康分析页面 UI（含骨架屏和加载动画）

**任务描述：**
- 创建健康分析页面
- 显示健康评分（大数字显示）
- 显示营养分析（卡路里、蛋白质、脂肪、碳水）
- 使用进度条显示营养摄入比例（相对于推荐摄入量）
- **实现骨架屏**：数据加载时显示骨架屏
- **实现加载动画**：数据刷新时显示加载动画
- **显示友好错误信息**：网络错误或数据错误时显示友好提示

**验证测试：**
- 页面应正确显示所有数据
- 进度条应正确反映摄入比例（相对于推荐摄入量）
- 加载时应显示骨架屏（不是空白）
- 错误时应显示友好的错误信息（不是技术错误）
- 页面首次加载时间应小于 1.5 秒

### 3.24 实现基础饮食建议生成

**任务描述：**
- 在健康分析服务中实现 `generateSuggestions` 方法
- 基于营养分析结果生成简单建议
- 例如：卡路里不足时建议增加摄入，蛋白质不足时建议补充蛋白质

**验证测试：**
- 不同营养状况应生成不同的建议
- 建议应清晰易懂
- 建议应基于实际分析结果

### 3.27 集成健康分析到前端

**任务描述：**
- 创建获取健康分析的 React Query Hook
- 在健康分析页面调用并显示建议
- 显示建议列表
- **实现友好错误处理**：API 错误时显示用户友好的错误信息
- 处理用户未设置资料的情况，提示用户完善资料

**验证测试：**
- 应正确显示建议
- 建议应根据实际数据生成
- 无数据时应显示友好的提示信息
- API 错误时应显示友好错误信息（不是技术错误）
- 用户未设置资料时应显示提示

---

## 阶段 4：完整功能（后续添加）

### 4.1 图像识别功能
- 集成图像识别 API
- 实现图片上传功能
- 识别菜品并自动填充表单

### 4.2 个性化推荐
- 基于用户历史记录分析偏好
- 实现协同过滤推荐算法
- 考虑营养均衡的推荐

### 4.3 高级健康分析
- 长期趋势分析
- 营养缺失识别
- 健康问题预警

### 4.4 用户偏好设置
- 饮食偏好配置
- 健康目标设置
- 个性化推荐参数

---

## 测试策略

### 单元测试
- 每个服务方法应有单元测试
- 每个工具函数应有单元测试
- 营养成分计算函数应有完整测试
- 推荐摄入量计算函数应有完整测试
- 健康评分算法应有完整测试
- 目标覆盖率：80%+

### 集成测试
- API 端点应有集成测试
- 数据库操作应有集成测试
- 认证流程应有端到端测试
- 所有 API 端点应测试响应时间（< 1s）

### 前端测试
- 关键组件应有渲染测试
- 用户交互应有测试
- API 调用应有 mock 测试
- 骨架屏和加载动画应有测试
- 错误处理应有测试

### 性能测试
- 所有 API 端点响应时间应 < 1 秒
- 前端页面首次加载时间应 < 1.5 秒
- 使用工具（如 Lighthouse）进行性能测试

---

## 部署准备

### 后端部署
- 配置生产环境变量
- 设置数据库连接池
- 配置日志系统
- 设置健康检查端点

### 前端部署
- 配置生产环境 API URL
- 构建生产版本
- 配置 OTA 更新

---

## 注意事项

1. **每个步骤完成后必须验证**：不要跳过验证测试
2. **保持代码简洁**：遵循 cursor rules 中的规范
3. **及时提交代码**：每完成一个步骤就提交一次
4. **处理错误情况**：每个功能都要考虑错误处理，使用统一错误格式
5. **保持文档同步**：如有变更，及时更新文档
6. **性能要求**：每个 API 完成后测试响应时间，确保 < 1 秒
7. **用户体验**：所有加载状态使用骨架屏，所有错误显示友好信息
8. **数据验证**：前后端都要验证，前端验证提升体验，后端验证保证安全
9. **API 版本控制**：所有端点使用 `/v1` 前缀
10. **Swagger 文档**：每个新 API 都要更新 Swagger 文档

---

**文档版本**：v1.0  
**最后更新**：2025年12月31日

